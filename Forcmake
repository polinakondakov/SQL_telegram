#include <iostream>
#include <vector>
#include <string>
#include <unordered_map>
#include <memory>
#include <random>
#include <cmath>
#include <fstream>
#include <sstream>
#include <iomanip>
#include <algorithm>

using namespace std;

// =========== БАЗОВЫЕ СТРУКТУРЫ ===========

/**
 * @brief Структура Vector3 представляет трехмерный вектор
 * Используется для хранения позиции, скорости, ускорения и других физических величин
 */
struct Vector3 {
    double x, y, z;

    // Конструктор с параметрами по умолчанию
    Vector3(double x = 0, double y = 0, double z = 0) : x(x), y(y), z(z) {}

    // Оператор сложения векторов
    Vector3 operator+(const Vector3& other) const {
        return Vector3(x + other.x, y + other.y, z + other.z);
    }

    // Оператор вычитания векторов
    Vector3 operator-(const Vector3& other) const {
        return Vector3(x - other.x, y - other.y, z - other.z);
    }

    // Оператор умножения вектора на скаляр
    Vector3 operator*(double scalar) const {
        return Vector3(x * scalar, y * scalar, z * scalar);
    }

    // Оператор деления вектора на скаляр
    Vector3 operator/(double scalar) const {
        // Проверка деления на ноль (опционально, но рекомендуется)
        if (scalar == 0.0) {
            cerr << "Предупреждение: деление на ноль в Vector3::operator/!" << endl;
            // Возвращаем вектор с очень большими значениями или ноль, в зависимости от логики
            // Здесь возвращаем ноль.
            return Vector3(0, 0, 0);
        }
        return Vector3(x / scalar, y / scalar, z / scalar);
    }

    // Преобразование вектора в строку для вывода в CSV
    string toString() const {
        return to_string(x) + "," + to_string(y) + "," + to_string(z);
    }

    // Проверка валидности вектора (отсутствие NaN и бесконечностей)
    bool isValid() const {
        return !isnan(x) && !isnan(y) && !isnan(z);
    }
};

/**
 * @brief Структура EulerAngles представляет углы Эйлера
 * Используется для описания ориентации объекта в пространстве
 */
struct EulerAngles {
    double roll, pitch, yaw;  // Крен, Тангаж, Рыскание

    EulerAngles(double r = 0, double p = 0, double y = 0) : roll(r), pitch(p), yaw(y) {}

    // Преобразование углов в строку для CSV
    string toString() const {
        return to_string(roll) + "," + to_string(pitch) + "," + to_string(yaw);
    }
};

/**
 * @brief Структура GeoPosition представляет географические координаты
 * Широта, долгота и высота над уровнем моря
 */
struct GeoPosition {
    double latitude, longitude, altitude;

    GeoPosition(double lat = 0, double lon = 0, double alt = 0)
        : latitude(lat), longitude(lon), altitude(alt) {
    }

    string toString() const {
        return to_string(latitude) + "," + to_string(longitude) + "," + to_string(altitude);
    }
};

// =========== ТОЧКА ТРАЕКТОРИИ ===========

/**
 * @brief Структура TrajectoryPoint представляет полное состояние объекта в момент времени
 * Содержит все кинематические параметры и ориентацию
 */
struct TrajectoryPoint {
    double time;                // Время в секундах
    Vector3 position;           // Позиция в декартовых координатах (метры)
    Vector3 velocity;           // Скорость (м/с)
    Vector3 acceleration;       // Ускорение (м/с²)
    Vector3 angular_velocity;   // Угловая скорость (рад/с)
    EulerAngles orientation;    // Ориентация (углы Эйлера)
    GeoPosition geo_position;   // Географические координаты

    // Конструктор с временем по умолчанию 0
    TrajectoryPoint(double t = 0) : time(t) {}

    /**
     * @brief Преобразование точки траектории в строку CSV формата
     * Формат: Time,PosX,PosY,PosZ,VelX,VelY,VelZ,AccX,AccY,AccZ,AngVelX,AngVelY,AngVelZ,Roll,Pitch,Yaw,Latitude,Longitude,Altitude
     */
    string toCSV() const {
        stringstream ss;
        ss << fixed << setprecision(8)  // Фиксированная точность 8 знаков после запятой
            << time << ","
            << position.toString() << ","
            << velocity.toString() << ","
            << acceleration.toString() << ","
            << angular_velocity.toString() << ","
            << orientation.toString() << ","
            << geo_position.toString();
        return ss.str();
    }

    /**
     * @brief Проверка валидности точки траектории
     * Все основные параметры должны быть корректными числами
     */
    bool isValid() const {
        return !isnan(time) && position.isValid() && velocity.isValid() && acceleration.isValid();
    }
};

// =========== МОДЕЛИ ОШИБОК ===========

/**
 * @brief Базовый класс ErrorModel для моделей ошибок датчиков
 * Определяет интерфейс для применения ошибок к идеальным измерениям
 */
class ErrorModel {
protected:
    string name;                    // Название модели ошибки
    bool enabled;                   // Флаг активности ошибки
    default_random_engine generator; // Генератор случайных чисел

public:
    ErrorModel(const string& model_name) : name(model_name), enabled(true) {
        random_device rd;           // Инициализация случайным seed
        generator.seed(rd());
    }
    virtual ~ErrorModel() {}

    // Виртуальные методы для применения ошибок к скалярным и векторным значениям
    virtual double applyError(double ideal_value, double dt) = 0;
    virtual Vector3 applyError(const Vector3& ideal_value, double dt) = 0;

    string getName() const { return name; }
    bool isEnabled() const { return enabled; }
    void setEnabled(bool state) { enabled = state; }
    void toggle() { enabled = !enabled; }
};

/**
 * @brief Класс BiasError моделирует систематическое смещение нуля (bias)
 * Постоянное смещение + небольшой случайный шум
 */
class BiasError : public ErrorModel {
private:
    double bias_value;                      // Величина систематического смещения
    normal_distribution<double> distribution; // Нормальное распределение для шума

public:
    BiasError(double bias = 0.1)
        : ErrorModel("BiasError"), bias_value(bias), distribution(0.0, 0.01) {
    }

    // Применение ошибки к скалярному значению
    double applyError(double ideal_value, double dt) override {
        if (!enabled) return ideal_value;
        return ideal_value + bias_value + distribution(generator);
    }

    // Применение ошибки к векторному значению (ко всем компонентам)
    Vector3 applyError(const Vector3& ideal_value, double dt) override {
        if (!enabled) return ideal_value;
        return Vector3(
            ideal_value.x + bias_value + distribution(generator),
            ideal_value.y + bias_value + distribution(generator),
            ideal_value.z + bias_value + distribution(generator)
        );
    }
};

/**
 * @brief Класс NoiseError моделирует белый шум измерений
 * Случайные флуктуации вокруг истинного значения
 */
class NoiseError : public ErrorModel {
private:
    normal_distribution<double> distribution; // Нормальное распределение шума

public:
    NoiseError(double std_dev = 0.05)
        : ErrorModel("NoiseError"), distribution(0.0, std_dev) {
    }

    double applyError(double ideal_value, double dt) override {
        if (!enabled) return ideal_value;
        return ideal_value + distribution(generator);
    }

    Vector3 applyError(const Vector3& ideal_value, double dt) override {
        if (!enabled) return ideal_value;
        return Vector3(
            ideal_value.x + distribution(generator),
            ideal_value.y + distribution(generator),
            ideal_value.z + distribution(generator)
        );
    }
};

// =========== СОСТОЯНИЕ ДАТЧИКОВ ===========

/**
 * @brief Структура SensorStaticParams содержит статические параметры датчика
 * Параметры, которые не меняются в процессе работы
 */
struct SensorStaticParams {
    string name;                // Название датчика
    double sampling_frequency;  // Частота дискретизации (Гц)

    SensorStaticParams(const string& n = "", double sf = 100.0)
        : name(n), sampling_frequency(sf) {
    }
};

/**
 * @brief Структура SensorDynamicEvent содержит динамическое состояние датчика
 * Параметры, которые меняются в процессе измерений
 */
struct SensorDynamicEvent {
    double time;                        // Текущее время
    bool is_valid;                      // Флаг валидности последнего измерения
    double last_valid_measurement_time; // Время последнего валидного измерения
    Vector3 last_measurement;           // Последнее измеренное значение

    SensorDynamicEvent(double t = 0)
        : time(t), is_valid(true), last_valid_measurement_time(t) {
    }
};

// =========== БАЗОВЫЙ КЛАСС ДАТЧИКА ===========

/**
 * @brief Базовый класс Sensor для всех типов датчиков
 * Реализует общую логику работы датчиков и применения ошибок
 */
class Sensor {
protected:
    SensorStaticParams static_params;           // Статические параметры
    SensorDynamicEvent dynamic_state;           // Динамическое состояние
    vector<shared_ptr<ErrorModel>> error_models; // Модели ошибок
    double last_measurement_time;               // Время последнего измерения

public:
    Sensor(const SensorStaticParams& params)
        : static_params(params), dynamic_state(0), last_measurement_time(0) {
    }

    virtual ~Sensor() {}

    // Добавление модели ошибок к датчику
    void addErrorModel(shared_ptr<ErrorModel> model) {
        error_models.push_back(model);
    }

    // Получение списка всех ошибок датчика
    vector<shared_ptr<ErrorModel>>& getErrorModels() {
        return error_models;
    }

    // Включение/выключение конкретной ошибки по индексу
    void setErrorModelEnabled(int index, bool enabled) {
        if (index >= 0 && index < error_models.size()) {
            error_models[index]->setEnabled(enabled);
        }
    }

    // Переключение состояния ошибки по индексу
    void toggleErrorModel(int index) {
        if (index >= 0 && index < error_models.size()) {
            error_models[index]->toggle();
        }
    }

    /**
     * @brief Проверка необходимости выполнения измерения на основе частоты дискретизации
     * @param current_time текущее время симуляции
     * @return true если прошло достаточно времени для нового измерения
     */
    bool shouldSample(double current_time) {
        double dt = current_time - last_measurement_time;
        return dt >= (1.0 / static_params.sampling_frequency);
    }

    /**
     * @brief Виртуальный метод для получения идеального измерения
     * Должен быть реализован в производных классах
     */
    virtual Vector3 getIdealMeasurement(const TrajectoryPoint& state) = 0;

    /**
     * @brief Основной метод получения измерения с учетом ошибок
     * @param state текущее состояние объекта
     * @return измеренное значение с примененными ошибками
     */
    Vector3 getMeasurement(const TrajectoryPoint& state) {
        // Проверяем, нужно ли делать новое измерение
        if (!shouldSample(state.time)) {
            return dynamic_state.last_measurement; // Возвращаем последнее значение
        }

        // Получаем идеальное значение от датчика
        Vector3 ideal_value = getIdealMeasurement(state);
        Vector3 measured_value = ideal_value;

        // Применяем все модели ошибок последовательно (только включенные)
        double dt = state.time - last_measurement_time;
        for (auto& model : error_models) {
            if (model->isEnabled()) {
                measured_value = model->applyError(measured_value, dt);
            }
        }

        // Обновляем динамическое состояние датчика
        dynamic_state.time = state.time;
        dynamic_state.is_valid = measured_value.isValid();
        if (dynamic_state.is_valid) {
            dynamic_state.last_valid_measurement_time = state.time;
            dynamic_state.last_measurement = measured_value;
        }

        last_measurement_time = state.time;
        return measured_value;
    }

    string getName() const { return static_params.name; }
};

// =========== КОНКРЕТНЫЕ ДАТЧИКИ ===========

/**
 * @brief Класс Accelerometer - датчик ускорения
 * Измеряет линейное ускорение объекта
 */
class Accelerometer : public Sensor {
public:
    Accelerometer(double freq = 100.0)
        : Sensor(SensorStaticParams("Accelerometer", freq)) {
    }

    // Возвращает вектор ускорения из состояния объекта
    Vector3 getIdealMeasurement(const TrajectoryPoint& state) override {
        return state.acceleration;
    }
};

/**
 * @brief Класс Gyroscope - гироскоп
 * Измеряет угловую скорость вращения объекта
 */
class Gyroscope : public Sensor {
public:
    Gyroscope(double freq = 100.0)
        : Sensor(SensorStaticParams("Gyroscope", freq)) {
    }

    // Возвращает вектор угловой скорости из состояния объекта
    Vector3 getIdealMeasurement(const TrajectoryPoint& state) override {
        return state.angular_velocity;
    }
};

/**
 * @brief Класс GNSS - спутниковая навигационная система
 * Измеряет позицию объекта в пространстве
 */
class GNSS : public Sensor {
public:
    GNSS(double freq = 10.0)  // Низкая частота, т.к. GNSS обычно медленнее
        : Sensor(SensorStaticParams("GNSS", freq)) {
    }

    // Возвращает вектор позиции из состояния объекта
    Vector3 getIdealMeasurement(const TrajectoryPoint& state) override {
        return state.position;
    }
};

/**
 * @brief Класс Lag - доплеровский измеритель скорости (ЛАГ)
 * Измеряет относительную скорость объекта (например, относительно воды или воздуха)
 * В упрощённой модели идеальное измерение - это истинная скорость минус скорость ветра/течения
 */
class Lag : public Sensor {
private:
    Vector3 wind_or_current; // Вектор внешнего воздействия (ветер или течение)

public:
    Lag(double freq = 50.0, Vector3 wind = Vector3(0, 0, 0)) // Средняя частота
        : Sensor(SensorStaticParams("Lag", freq)), wind_or_current(wind) {
    }

    // Возвращает вектор скорости относительно среды (истинная скорость - ветер/течение)
    Vector3 getIdealMeasurement(const TrajectoryPoint& state) override {
        return state.velocity - wind_or_current;
    }

    void setWindOrCurrent(const Vector3& wind) { wind_or_current = wind; }
    Vector3 getWindOrCurrent() const { return wind_or_current; }
};

// =========== ГЕНЕРАТОР ТРАЕКТОРИИ ===========

/**
 * @brief Перечисление MotionType определяет типы движения объекта
 */
enum MotionType {
    UNIFORM,      // Равномерное прямолинейное движение (постоянная скорость)
    ACCELERATED,  // Равноускоренное движение (постоянное ускорение)
    CIRCULAR      // Движение по окружности (постоянная угловая скорость)
};

/**
 * @brief Структура TrajectorySegment описывает сегмент траектории
 * Каждый сегмент имеет свой тип движения и параметры
 */
struct TrajectorySegment {
    MotionType type;           // Тип движения
    double duration;           // Продолжительность сегмента (секунды)
    Vector3 start_position;    // Начальная позиция сегмента
    Vector3 start_velocity;    // Начальная скорость сегмента
    Vector3 acceleration;      // Ускорение (для ACCELERATED)
    Vector3 center;           // Центр окружности (для CIRCULAR)
    double radius;            // Радиус окружности (для CIRCULAR)
    double angular_velocity;  // Угловая скорость (для CIRCULAR)

    // Конструктор с параметрами по умолчанию
    TrajectorySegment(MotionType t, double d, Vector3 start = Vector3())
        : type(t), duration(d), start_position(start), radius(5.0), angular_velocity(1.0) {
    }
};

/**
 * @brief Структура TrajectoryConfig содержит конфигурацию траектории
 * Определяет источник данных и параметры генерации
 */
struct TrajectoryConfig {
    enum SourceType {
        GENERATED,  // Траектория генерируется алгоритмически
        FROM_FILE   // Траектория загружается из файла
    };

    SourceType source_type;    // Источник траектории
    string file_path;          // Путь к файлу (для FROM_FILE)
    vector<TrajectorySegment> segments; // Сегменты траектории (для GENERATED)
    double time_step;          // Шаг времени для дискретизации (секунды)
    GeoPosition start_geo_position; // Начальные географические координаты

    // Конструктор с параметрами по умолчанию (Москва)
    TrajectoryConfig(SourceType source = GENERATED, double step = 0.1)
        : source_type(source), time_step(step), start_geo_position(55.7558, 37.6173, 150) {
    }
};

// =========== СИСТЕМА ВВОДА ОТ ПОЛЬЗОВАТЕЛЯ ===========

/**
 * @brief Класс InputSystem отвечает за взаимодействие с пользователем
 * Собирает все необходимые параметры для симуляции
 */
class InputSystem {
private:
    /**
     * @brief Ввод вещественного числа с подсказкой. Пустой ввод не разрешён.
     */
    double getDouble(const string& prompt) {
        while (true) {
            cout << prompt;
            string input;
            getline(cin, input);
            if (!input.empty()) {
                try {
                    return stod(input);
                } catch (const exception&) {
                    cout << "Некорректный ввод. Пожалуйста, введите число.\n";
                }
            } else {
                cout << "Ввод не может быть пустым. Пожалуйста, введите число.\n";
            }
        }
    }

    /**
     * @brief Ввод целого числа с подсказкой. Пустой ввод не разрешён.
     */
    int getInt(const string& prompt) {
        while (true) {
            cout << prompt;
            string input;
            getline(cin, input);
            if (!input.empty()) {
                try {
                    return stoi(input);
                } catch (const exception&) {
                    cout << "Некорректный ввод. Пожалуйста, введите целое число.\n";
                }
            } else {
                cout << "Ввод не может быть пустым. Пожалуйста, введите целое число.\n";
            }
        }
    }

    /**
     * @brief Ввод трехмерного вектора с подсказкой.
     */
    Vector3 getVector3(const string& prompt) {
        cout << prompt << endl;
        double x = getDouble("  X: ");
        double y = getDouble("  Y: ");
        double z = getDouble("  Z: ");
        return Vector3(x, y, z);
    }

    /**
     * @brief Выбор из меню с несколькими вариантами
     */
    int getChoice(const string& prompt, const vector<string>& options) {
        cout << prompt << ":" << endl;
        for (int i = 0; i < options.size(); i++) {
            cout << "  " << (i + 1) << ". " << options[i] << endl;
        }
        while (true) {
            int choice = getInt("Выберите вариант: ");
            if (choice >= 1 && choice <= (int)options.size()) {
                return choice - 1; // Возвращаем индекс (0-based)
            }
            cout << "Некорректный выбор. Пожалуйста, выберите от 1 до " << options.size() << ".\n";
        }
    }

    /**
     * @brief Ввод географических координат от пользователя
     */
    GeoPosition getGeoPosition() {
        cout << "\n--- Начальные географические координаты ---" << endl;
        double lat = getDouble("Широта (градусы): ");
        double lon = getDouble("Долгота (градусы): ");
        double alt = getDouble("Высота над уровнем моря (метры): ");
        return GeoPosition(lat, lon, alt);
    }

public:
    /**
     * @brief Чтение конфигурации траектории от пользователя
     * Пользователь выбирает источник данных и задает параметры
     */
    TrajectoryConfig readScenarioConfig() {
        cout << "\n=== НАСТРОЙКА ТРАЕКТОРИИ ===" << endl;

        int source_choice = getChoice("Источник траектории", {
            "Сгенерировать новую траекторию",
            "Загрузить из файла"
        });

        TrajectoryConfig config;
        config.source_type = (source_choice == 0) ? TrajectoryConfig::GENERATED : TrajectoryConfig::FROM_FILE;

        // Обработка загрузки из файла
        if (config.source_type == TrajectoryConfig::FROM_FILE) {
            cout << "Введите путь к файлу траектории: ";
            getline(cin, config.file_path);
            while (config.file_path.empty()) {
                cout << "Путь не может быть пустым. Введите путь к файлу траектории: ";
                getline(cin, config.file_path);
            }
            config.time_step = getDouble("Шаг времени для дискретизации (секунды): ");
            config.start_geo_position = getGeoPosition();
            return config;
        }

        // Генерация новой траектории
        config.time_step = getDouble("Шаг времени (секунды): ");
        config.start_geo_position = getGeoPosition();

        int segment_count = getInt("Количество сегментов траектории: ");

        // Текущее состояние для последовательного построения траектории
        Vector3 current_pos = Vector3(0, 0, 0);
        Vector3 current_vel = Vector3(0, 0, 0);

        // Создание каждого сегмента траектории
        for (int i = 0; i < segment_count; i++) {
            cout << "\n--- Сегмент " << (i + 1) << " ---" << endl;

            int motion_type = getChoice("Тип движения", {
                "Равномерное прямолинейное",
                "Равноускоренное движение",
                "Движение по окружности"
            });

            double duration = getDouble("Длительность сегмента (секунды): ");

            TrajectorySegment segment(static_cast<MotionType>(motion_type), duration, current_pos);

            // Настройка параметров в зависимости от типа движения
            switch (motion_type) {
            case UNIFORM:
                segment.start_velocity = getVector3("Начальная скорость (м/с):");
                current_vel = segment.start_velocity;
                // Позиция изменяется по формуле: s = s0 + v * t
                current_pos = current_pos + segment.start_velocity * duration;
                break;

            case ACCELERATED:
                segment.start_velocity = current_vel;
                segment.acceleration = getVector3("Ускорение (м/с²):");
                // Скорость изменяется по формуле: v = v0 + a * t
                current_vel = current_vel + segment.acceleration * duration;
                // Позиция изменяется по формуле: s = s0 + v0*t + (a*t²)/2
                current_pos = current_pos + segment.start_velocity * duration + segment.acceleration * (duration * duration * 0.5);
                break;

            case CIRCULAR:
                segment.center = current_pos;
                segment.radius = getDouble("Радиус окружности (метры): ");
                segment.angular_velocity = getDouble("Угловая скорость (рад/с): ");
                current_vel = Vector3(0, 0, 0); // Сбрасываем скорость для следующего сегмента
                // Начальная позиция для следующего сегмента - точка на окружности
                current_pos = segment.center + Vector3(segment.radius, 0, 0);
                break;
            }

            config.segments.push_back(segment);
        }

        return config;
    }

    /**
     * @brief Создание и настройка датчиков
     * Пользователь выбирает типы датчиков и их параметры
     */
    vector<shared_ptr<Sensor>> createSensors() {
        cout << "\n=== НАСТРОЙКА ДАТЧИКОВ ===" << endl;

        vector<shared_ptr<Sensor>> sensors;
        int sensor_count = getInt("Количество датчиков: ");

        for (int i = 0; i < sensor_count; i++) {
            cout << "\n--- Датчик " << (i + 1) << " ---" << endl;

            int sensor_type = getChoice("Тип датчика", {
                "Акселерометр",
                "Гироскоп",
                "GNSS приемник",
                "ЛАГ (Доплеровский измеритель скорости)"
            });

            double frequency = getDouble("Частота дискретизации (Гц): ");

            shared_ptr<Sensor> sensor;

            // Создание датчика конкретного типа и настройка его ошибок
            switch (sensor_type) {
            case 0: // Акселерометр
                sensor = make_shared<Accelerometer>(frequency);
                double acc_bias = getDouble("Смещение нуля акселерометра: ");
                double acc_noise = getDouble("Шум акселерометра: ");
                sensor->addErrorModel(make_shared<BiasError>(acc_bias));
                sensor->addErrorModel(make_shared<NoiseError>(acc_noise));
                break;
            case 1: // Гироскоп
                sensor = make_shared<Gyroscope>(frequency);
                double gyro_bias = getDouble("Смещение нуля гироскопа: ");
                double gyro_noise = getDouble("Шум гироскопа: ");
                sensor->addErrorModel(make_shared<BiasError>(gyro_bias));
                sensor->addErrorModel(make_shared<NoiseError>(gyro_noise));
                break;
            case 2: // GNSS
                sensor = make_shared<GNSS>(frequency);
                double gnss_noise = getDouble("Шум GNSS: ");
                sensor->addErrorModel(make_shared<NoiseError>(gnss_noise));
                break;
            case 3: // ЛАГ
            {
                Vector3 wind = getVector3("Скорость ветра/течения (м/с):");
                sensor = make_shared<Lag>(frequency, wind);
                // Просто добавляем шум как основную "ошибку" для ЛАГа
                double lag_noise = getDouble("Шум ЛАГа: ");
                sensor->addErrorModel(make_shared<NoiseError>(lag_noise));
            }
            break;
            }

            // Настройка включения/выключения ошибок для этого датчика
            auto& error_models = sensor->getErrorModels();
            if (!error_models.empty()) {
                cout << "Настройка ошибок для " << sensor->getName() << ":" << endl;
                for (int j = 0; j < error_models.size(); j++) {
                    string status = error_models[j]->isEnabled() ? "ВКЛ" : "ВЫКЛ";
                    cout << "  " << (j + 1) << ". " << error_models[j]->getName()
                        << " [" << status << "]" << endl;
                }
                cout << "Хотите изменить состояние ошибок? (1 - Да, 0 - Нет): ";
                int modify_errors;
                cin >> modify_errors;
                cin.ignore(); // Очистка буфера
                if (modify_errors == 1) {
                    for (int j = 0; j < error_models.size(); j++) {
                        string current_status = error_models[j]->isEnabled() ? "ВКЛ" : "ВЫКЛ";
                        cout << "Ошибка " << error_models[j]->getName() << " сейчас " << current_status;
                        int enable = getInt(". Включить? (1 - Да, 0 - Нет): ");
                        sensor->setErrorModelEnabled(j, enable == 1);
                    }
                }
            }

            sensors.push_back(sensor);
        }

        return sensors;
    }

    /**
     * @brief Получение имени файла для сохранения результатов
     */
    string getOutputFilename() {
        cout << "\n=== СОХРАНЕНИЕ РЕЗУЛЬТАТОВ ===" << endl;
        string filename;
        while (filename.empty()) {
            cout << "Имя файла для сохранения: ";
            getline(cin, filename);
            if (filename.empty()) {
                cout << "Имя файла не может быть пустым.\n";
            }
        }
        return filename;
    }
};

// =========== ГЕНЕРАТОР ТРАЕКТОРИИ ===========

/**
 * @brief Класс TrajectoryGenerator отвечает за создание траектории движения
 * Может генерировать траекторию алгоритмически или загружать из файла
 */
class TrajectoryGenerator {
private:
    TrajectoryConfig config;

    /**
     * @brief Преобразование географических координат в декартовы
     * @param geo географические координаты
     * @return декартовы координаты относительно начальной точки
     */
    Vector3 geoToCartesian(const GeoPosition& geo) const {
        const double METERS_PER_DEGREE = 111000.0; // Приблизительная длина градуса в метрах
        return Vector3(
            (geo.longitude - config.start_geo_position.longitude) * METERS_PER_DEGREE,
            (geo.latitude - config.start_geo_position.latitude) * METERS_PER_DEGREE,
            geo.altitude - config.start_geo_position.altitude
        );
    }

    /**
     * @brief Преобразование декартовых координат в географические
     * @param pos декартовы координаты
     * @return географические координаты
     */
    GeoPosition cartesianToGeo(const Vector3& pos) const {
        const double METERS_PER_DEGREE = 111000.0;
        return GeoPosition(
            config.start_geo_position.latitude + pos.y / METERS_PER_DEGREE,
            config.start_geo_position.longitude + pos.x / METERS_PER_DEGREE,
            config.start_geo_position.altitude + pos.z
        );
    }

    /**
     * @brief Загрузка траектории из файла
     * Поддерживает форматы с декартовыми и географическими координатами
     * Вычисляет скорость и ускорение как производные от позиции.
     */
    vector<TrajectoryPoint> loadFromFile() {
        vector<TrajectoryPoint> trajectory;
        ifstream file(config.file_path);

        if (!file.is_open()) {
            cerr << "Ошибка: не удалось открыть файл " << config.file_path << endl;
            return trajectory;
        }

        string line;
        getline(file, line); // Пропускаем заголовок CSV

        // Чтение данных построчно
        while (getline(file, line)) {
            stringstream ss(line);
            string token;
            vector<double> values;

            // Разбиваем строку на числа по запятым
            while (getline(ss, token, ',')) {
                values.push_back(stod(token));
            }

            // Минимум 3 значения: время и координаты
            if (values.size() >= 3) {
                TrajectoryPoint point;
                point.time = values[0];

                // Определяем формат файла по количеству столбцов
                if (values.size() >= 6) {
                    // Файл содержит декартовы координаты (Time,X,Y,Z,...)
                    point.position = Vector3(values[1], values[2], values.size() > 3 ? values[3] : 0);
                }
                else {
                    // Файл содержит географические координаты (Time,Lat,Lon,Alt)
                    GeoPosition geo(values[1], values[2], values.size() > 3 ? values[3] : 0);
                    point.position = geoToCartesian(geo);
                }

                // Заполняем остальные поля значениями по умолчанию
                point.geo_position = cartesianToGeo(point.position);
                // point.velocity и point.acceleration будут вычислены ниже
                point.angular_velocity = Vector3(0, 0, 0);
                point.orientation = EulerAngles(0, 0, 0);

                if (point.isValid()) {
                    trajectory.push_back(point);
                }
            }
        }

        file.close();
        cout << "Загружено точек из файла: " << trajectory.size() << endl;

        // Вычисление скорости и ускорения по загруженной траектории
        if (trajectory.size() < 2) {
            // Недостаточно точек для вычисления производных
            if (!trajectory.empty()) {
                trajectory[0].velocity = Vector3(0, 0, 0);
                trajectory[0].acceleration = Vector3(0, 0, 0);
            }
            return trajectory;
        }

        for (size_t i = 0; i < trajectory.size(); ++i) {
            if (i == 0) {
                // Первая точка: односторонняя разность вперёд
                double dt = trajectory[1].time - trajectory[0].time;
                if (dt != 0) {
                    trajectory[i].velocity = (trajectory[1].position - trajectory[0].position) / dt;
                }
                else {
                    trajectory[i].velocity = Vector3(0, 0, 0);
                }
                // Ускорение: односторонняя разность для скорости
                if (trajectory.size() > 2) {
                    double dt2 = trajectory[2].time - trajectory[0].time;
                    Vector3 vel_next = (trajectory[2].position - trajectory[1].position) / (trajectory[2].time - trajectory[1].time);
                    if (dt2 != 0) {
                        trajectory[i].acceleration = (vel_next - trajectory[i].velocity) / dt2;
                    }
                    else {
                        trajectory[i].acceleration = Vector3(0, 0, 0);
                    }
                }
                else {
                    trajectory[i].acceleration = Vector3(0, 0, 0);
                }
            }
            else if (i == trajectory.size() - 1) {
                // Последняя точка: односторонняя разность назад
                double dt = trajectory[i].time - trajectory[i - 1].time;
                if (dt != 0) {
                    trajectory[i].velocity = (trajectory[i].position - trajectory[i - 1].position) / dt;
                }
                else {
                    trajectory[i].velocity = Vector3(0, 0, 0);
                }
                // Ускорение: односторонняя разность для скорости
                Vector3 vel_prev = (trajectory[i - 1].position - trajectory[i - 2].position) / (trajectory[i - 1].time - trajectory[i - 2].time);
                double dt_prev = trajectory[i].time - trajectory[i - 2].time;
                if (dt_prev != 0) {
                    trajectory[i].acceleration = (trajectory[i].velocity - vel_prev) / dt_prev;
                }
                else {
                    trajectory[i].acceleration = Vector3(0, 0, 0);
                }
            }
            else {
                // Точка внутри: центральная разность
                double dt_prev = trajectory[i].time - trajectory[i - 1].time;
                double dt_next = trajectory[i + 1].time - trajectory[i].time;
                double dt_total = trajectory[i + 1].time - trajectory[i - 1].time;
                if (dt_total != 0) {
                    trajectory[i].velocity = (trajectory[i + 1].position - trajectory[i - 1].position) / dt_total;
                }
                else {
                    trajectory[i].velocity = Vector3(0, 0, 0);
                }
                // Ускорение: центральная разность для скорости
                Vector3 vel_next = (trajectory[i + 2].position - trajectory[i + 1].position) / (trajectory[i + 2].time - trajectory[i + 1].time);
                Vector3 vel_prev = (trajectory[i].position - trajectory[i - 1].position) / (trajectory[i].time - trajectory[i - 1].time);
                double dt_acc = trajectory[i + 1].time - trajectory[i - 1].time; // Используем тот же dt_total
                if (dt_acc != 0) {
                    trajectory[i].acceleration = (vel_next - vel_prev) / dt_acc;
                }
                else {
                    trajectory[i].acceleration = Vector3(0, 0, 0);
                }
            }
        }

        return trajectory;
    }

public:
    TrajectoryGenerator(const TrajectoryConfig& cfg) : config(cfg) {}

    /**
     * @brief Основной метод построения траектории
     * @return вектор точек траектории
     */
    vector<TrajectoryPoint> build() {
        // Загрузка из файла
        if (config.source_type == TrajectoryConfig::FROM_FILE) {
            return loadFromFile();
        }

        // Генерация траектории по сегментам
        vector<TrajectoryPoint> trajectory;
        double current_time = 0.0;

        // Обработка каждого сегмента траектории
        for (const auto& segment : config.segments) {
            // Генерация точек внутри сегмента с заданным шагом времени
            for (double t = 0; t <= segment.duration; t += config.time_step) {
                TrajectoryPoint point(current_time + t);

                // Расчет параметров в зависимости от типа движения
                switch (segment.type) {
                case UNIFORM:
                    // Равномерное движение: s = s0 + v * t
                    point.position = segment.start_position + segment.start_velocity * t;
                    point.velocity = segment.start_velocity;
                    point.acceleration = Vector3();
                    point.orientation = EulerAngles(0, 0, 0);
                    break;

                case ACCELERATED:
                    // Равноускоренное движение: s = s0 + v0*t + (a*t²)/2, v = v0 + a*t
                    point.position = segment.start_position + segment.start_velocity * t + segment.acceleration * (t * t * 0.5);
                    point.velocity = segment.start_velocity + segment.acceleration * t;
                    point.acceleration = segment.acceleration;
                    point.orientation = EulerAngles(0, 0, 0);
                    break;

                case CIRCULAR:
                {
                    // Движение по окружности в плоскости XY
                    double angle = segment.angular_velocity * t;
                    point.position = Vector3(
                        segment.center.x + segment.radius * cos(angle),
                        segment.center.y + segment.radius * sin(angle),
                        segment.center.z
                    );
                    // Скорость направлена по касательной к окружности
                    point.velocity = Vector3(
                        -segment.radius * segment.angular_velocity * sin(angle),
                        segment.radius * segment.angular_velocity * cos(angle),
                        0
                    );
                    // Центростремительное ускорение направлено к центру
                    point.acceleration = Vector3(
                        -segment.radius * segment.angular_velocity * segment.angular_velocity * cos(angle),
                        -segment.radius * segment.angular_velocity * segment.angular_velocity * sin(angle),
                        0
                    );
                    point.orientation = EulerAngles(0, 0, angle);
                }
                break;
                }

                point.angular_velocity = Vector3(0, 0, segment.angular_velocity);
                point.geo_position = cartesianToGeo(point.position);

                // Добавляем точку только если она валидна
                if (point.isValid()) {
                    trajectory.push_back(point);
                }
            }
            current_time += segment.duration;
        }

        return trajectory;
    }
};

// =========== МЕНЕДЖЕР СЦЕНАРИЯ ===========

/**
 * @brief Класс ScenarioManager - центральный управляющий компонент системы
 * Координирует работу траектории и датчиков, выполняет пошаговую симуляцию
 */
class ScenarioManager {
private:
    vector<TrajectoryPoint> trajectory;  // Вся траектория движения
    vector<shared_ptr<Sensor>> sensors;  // Все датчики системы
    double current_time;                 // Текущее время симуляции
    size_t current_step;                 // Текущий шаг симуляции

public:
    ScenarioManager() : current_time(0), current_step(0) {}

    // Установка траектории для симуляции
    void setTrajectory(const vector<TrajectoryPoint>& traj) {
        trajectory = traj;
    }

    // Добавление датчика в систему
    void addSensor(shared_ptr<Sensor> sensor) {
        sensors.push_back(sensor);
    }

    /**
     * @brief Выполнение одного шага симуляции
     * @return true если симуляция продолжается, false если завершена
     */
    bool step() {
        if (current_step >= trajectory.size()) return false;

        // Получаем текущее состояние объекта
        TrajectoryPoint current_state = trajectory[current_step];
        current_time = current_state.time;

        // Обновляем измерения всех датчиков
        for (auto& sensor : sensors) {
            sensor->getMeasurement(current_state);
        }

        current_step++;
        return true;
    }

    // Геттеры для доступа к данным
    vector<TrajectoryPoint> getTrajectory() const { return trajectory; }
    double getDuration() const { return trajectory.empty() ? 0 : trajectory.back().time; }
    vector<shared_ptr<Sensor>> getSensors() const { return sensors; }
};

// =========== СИСТЕМА ВЫВОДА ===========

/**
 * @brief Класс OutputSystem отвечает за сохранение результатов симуляции
 */
class OutputSystem {
public:
    /**
     * @brief Сохранение траектории в CSV файл
     * @param trajectory вектор точек траектории
     * @param filename имя файла для сохранения
     */
    void saveTrajectoryToCSV(const vector<TrajectoryPoint>& trajectory, const string& filename) {
        ofstream file(filename);
        if (!file.is_open()) {
            cerr << "Ошибка открытия файла: " << filename << endl;
            return;
        }

        // Заголовок CSV файла с описанием столбцов
        file << "Time,PosX,PosY,PosZ,VelX,VelY,VelZ,AccX,AccY,AccZ," << "AngVelX,AngVelY,AngVelZ,Roll,Pitch,Yaw,Latitude,Longitude,Altitude\n";

        // Запись каждой точки траектории
        for (const auto& point : trajectory) {
            if (point.isValid()) {
                file << point.toCSV() << "\n";
            }
        }

        file.close();
        cout << "Траектория сохранена в: " << filename << endl;
    }
};

// =========== ГЛАВНАЯ ПРОГРАММА ===========

/**
 * @brief Главная функция программы
 * Координирует работу всех компонентов системы
 */
int main() {
    cout << "=== СИМУЛЯТОР ДАТЧИКОВ ДВИЖЕНИЯ ===" << endl;

    // 1. Ввод данных от пользователя
    InputSystem input;
    TrajectoryConfig config = input.readScenarioConfig();
    auto sensors = input.createSensors();
    string filename = input.getOutputFilename();

    // 2. Генерация траектории
    cout << "\nГенерация траектории..." << endl;
    TrajectoryGenerator generator(config);
    auto trajectory = generator.build();

    // Проверка успешности создания траектории
    if (trajectory.empty()) {
        cerr << "Ошибка: не удалось создать траекторию!" << endl;
        return 1;
    }

    // 3. Настройка и запуск симуляции
    cout << "Запуск симуляции..." << endl;
    ScenarioManager scenario;
    scenario.setTrajectory(trajectory);
    for (auto& sensor : sensors) {
        scenario.addSensor(sensor);
    }

    // Расчет параметров для отображения прогресса
    int total_steps = trajectory.size();
    int progress_interval = max(1, total_steps / 10);

    // Главный цикл симуляции
    while (scenario.step()) {
        size_t current_step = scenario.getDuration() / config.time_step;
        // Вывод прогресса каждые 10%
        if (current_step % progress_interval == 0) {
            double progress = (current_step * 100.0) / total_steps;
            cout << "Прогресс: " << fixed << setprecision(1) << progress << "%" << endl;
        }
    }

    // 4. Сохранение результатов
    OutputSystem output;
    output.saveTrajectoryToCSV(trajectory, filename);

    // 5. Вывод статистики
    cout << "\n=== РЕЗУЛЬТАТЫ ===" << endl;
    cout << "Длительность: " << scenario.getDuration() << " с" << endl;
    cout << "Точек траектории: " << trajectory.size() << endl;
    cout << "Датчиков: " << sensors.size() << endl;
    cout << "Файл сохранен: " << filename << endl;
    cout << "Начальные координаты: " << config.start_geo_position.toString() << endl;

    return 0;
}
